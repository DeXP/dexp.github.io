---
layout: page
subheadline: "Delphi"
title:  "Создание бегущей строки в Delphi"
teaser: "Статья для начинающих. Расписано два способа создания бегущей строки. Знание HTML очень приветствуется."
categories: russian
tags:
    - russian
    - delphi
    - html
    - gui
#image:
#   thumb: "thumb/w2bf.png"
redirect_from:
  - "/articles/delphi/string+blp+en.html"
  - "/articles/delphi/string+blp+ru.html"
  - "/articles/delphi/string+npi+en.html"
  - "/articles/delphi/string+npi+ru.html"
  - "/articles/delphi/string+gray+en.html"
  - "/articles/delphi/string+gray+ru.html"
---

<center><table width="350" height="70"><tr><td align="center" style="vertical-align: middle; background-color: #ECE9D8; padding-top: 30px"><center><table style="border-width: 1px; border-style: inset; "><tr><td height="20"><marquee height="100%" width="167" bgcolor="white" Scrollamount="4">Такая же бегущая строка будет и у вас в Delphi-приложении</marquee></td></tr></table></center></td></tr></table></center
>
Итак, как вы уже догадались, сегодня мы будем делать бегущую строку в своём Delphi-приложении.
Однажды мне очень понадобилось некое подобие TEdit'a, только не со стационарной, а с бегущей строкой (все символы просто не влазили, а показать нужно было всё...) Вот я и задумался, как же это сделать. Сегодня я расскажу вам 2 способа решения данной проблeмы. 

Способ первый, он первым пришёл мне в голову. Поиграться со свойством Text Edit'a, т.е. через определённый промежуток времени "смещать" саму строку. Под смещением я понимаю удаление первого символа строки и добавление нового последнего. Таким образом получается цикл нужного нам текста.
Для этого кинем на форму один таймер, один TEdit и объявим глобальную переменную i сразу после слова implementation. i по умолчанию должно равняться единице, т.е. её объявление будет выглядеть так:

```pascal
...
implementation

var
   i: integer = 1;
...
```

А сам код таймера будет выглядеть так: 

```pascal
procedure TForm1.Timer1Timer(Sender: TObject);
const
   {Текст, который будет двигаться в Edit'e}
   GoString='А вoт и бегущая строка в Delphi :)';  
var
   s: string; {Временная переменная для работы с текстом}
   { т.к. удалять символы напрямую из Edit'a мы не можем}
begin
   s := Edit1.Text; {Берём текст}
   Delete(s,1,1); {Удаляем первый символ}
   {Добавляем в конец текста следующий по списку символ}
   s := s+GoString[i]; 
   Edit1.Text := s; {Возвращаем изменённый текст на родину}
   inc(i); {В следующий раз будем добавлять следующий символ}
   if i>length(GoString) then i := 1; 
   {Но если номер следующего символа вылазит за границу строки,
   то это знак что нужно начинать сначала}
end;
```

Для того, чтобы данный способ работал корректно, нужно чтобы изначально текст Edit'a был чем-то заполнен. Чем - не важно. Это будет видно только в самом начале. Можно просто взять кучу пробелов. Но длина текста останется постоянной, т.е. какая была, такой и останется...

Данный метод, конечно, хорош. Но передавать строки ему не очень удобно, а если строка должна ещё и периодически изменяться, то совсем неудобен. К тому же, смещение происходит посимвольно, что, если приглядеться, заметно. А мне хотелось, чтобы смещение было максимально плавным, да и кодить этот "ужасный" код совсем не хотелось - было мало времени.



Тогда я использовал способ второй. А суть заключается в том, что не надо изобретать велосипед, если он уже изобретён. Напряжём мозги и вспомним старый добрый HTML. Опа! А там же есть уже реализованная отличная бегущая строка! MARQUEE вспомнили? Если нет, то сейчас вспомните! :)

Данный тег с атрибутами выглядит примерно так:

```html
<marquee height="100%" width="167" bgcolor="white" behavior="scroll"
direction="left" scrollamount="4"> Текст бегущей строки </marquee>
```

- height - высота бегущей строки. В данном случае змеряется в процентах
- width - ширина бегущей строки. В данном случае измеряется в пикселях
- behavior - поведение строки. Может равняться:
  + Scroll - обычная прокрутка (можно не прописывать, оно так и есть по умолчанию)
  + Slide - прокрутка с остановкой, строка пробегает до края и останавливается.
  + Alternate - строка будет двигаться от края к краю.
- direction - задает направление движения бегущей строки. Может равняться left (right, up, down) - движение влево (вправо, вверх, вниз). Движение влево можно не прописывать, оно является движением по умолчанию.
- scrollamount - скорость движения строки. Может принимать значения от 1 до 10.

Конечно же, для бегущей строки можно задавать и другие HTML атрибуты (hspace, vspace и align).

Пример бегущей строки можете посмотреть вначале этой статьи. Её код выглядит так:

```html
<marquee height="100%" width="167" bgcolor="white" scrollamount="4">
  <small>Такая же бегущая строка будет и у вас в Delphi-приложении</small>
</marquee>
```

Тег small делает шрифт текста меньшим, относительно основного текста.

Ну вот, теорию повторили! :) Теперь перейдём к проблемам реализации.

Как вы уже догадались, показывать нашу страничку мы будем в TWebBrowser => для отображения бегущей строки мы используем Internet Explorer (точнее, TWebBrowser использует IE). Следовательно, и отображаться она будет всегда одинаково! Значит, никаких проблем с разностью в браузерах нет! Это хорошо.

Но, как же мы будем показывать нашу страничку, если TWebBrowser умеет открывать только существующие странички? Очень просто. Сохранять на диск нашу HTML страничку мы не будем - не респектно! :) Для отображения странички воспользуемся протоколом about. Коротко говоря об этом протоколе, если создать строку вида "about: Наш HTML код " и передать эту строку в качестве параметра в TWebBrowser.Navigate, то наша страничка корректно отобразиться. Например:

```pascal
WebBrowser1.Navigate('about:<body bgcolor="red">'+
'<center>Hello, DeXPeriX!</center></body>');
```

Этот код отобразит нам страничку с красным фоном, посередине которой на первой строке будет надпись "Hello, DeXPeriX!" чёрными буквами.

А почему бы нам не отобразить так же и бегущую строку? Пробуем! :)

```pascal
WebBrowser1.Navigate('about:<body>'+
'<marquee height="20" width="167" bgcolor="white" scrollamount="4">'+
'<small>Такая же бегущая строка будет и у вас в Delphi-приложении</small>'
+'</marquee></body>');
```

Уррряя! Всё работает! Так, теперь доведём всё до человеческого вида, т.е. Сделаем размеры нашего WebBrowser'a соизмеримыми с размерами Edit'a. В предвкушении законченого дела запускаем наше приложение и ... не тут то было! Эти чёртовы полосы прокрутки! Да ещё и сама строка находится не с самого верху! Мдя, будем лечить...
В HTML'e есть понятия нижнего, верхнего, левого и правого отступов от краёв страницы. А что если их обнулить?

```pascal
WebBrowser1.Navigate('about:<body topmargin="0" leftmargin="0" '+
'marginwidth="0" rightmargin="0" bottommargin="0">'+ 
'<marquee height="20" width="167" bgcolor="white" scrollamount="4">'+ 
'<small>Такая же бегущая строка будет и у вас в Delphi-приложении</small>'
+ '</marquee></body>');
```

Угу. Уже получше - если освободить место для полос прокрутки, то будет видно, что наша строка вплотную прилегает к краям TWebBrowser'a. Но полосы прокрутки портят весь вид! Вот их мы сейчас и уберём! :) 

А убираются они довольно просто: в теге body пролписываем scroll="no". Всё гениальное просто :). Делаем размер WebBrowser'a "нормальным" (у меня height=20 а width=167), изменяем текст на:

```pascal
WebBrowser1.Navigate('about:<body topmargin="0" leftmargin="0" '+
'marginwidth="0" rightmargin="0" bottommargin="0" scroll="no"> '+
'<marquee height="20" width="167" bgcolor="white" scrollamount="4">'+
'<small>Такая же бегущая строка будет и у вас в Delphi-приложении</small>'
+ '</marquee></body>');
```

И радуемся жизни: теперь то всё работает! Ну, для полного счастья можно подвязать размеры бегущей строки с размерами браузера. Это делается так:

```pascal
WebBrowser1.Navigate('about:<body topmargin="0" leftmargin="0" ' +
'marginwidth="0" rightmargin="0" bottommargin="0" scroll="no"> ' +
'<marquee height="' + IntToStr(WebBrowser1.height-5)+'" '+
'width="' + IntToStr(WebBrowser1.width) + 
'" bgcolor="white" scrollamount="4">' +
'<small>Такая же бегущая строка будет и у вас в Delphi-приложении</small>'
+ '</marquee></body>');
```

Теперь даже если попытаться прокрутить (скроллером или кнопкой мыши) нашу страничку, бегущая строка всё равно не изменит своей траектории. WebBrowser1.height-5 сделано именно для этого.

Ну и, наконец, всё это можно красиво оформить в одну процедурку:

```pascal
procedure SetRunText(Web: TWebBrowser; Text: string);
begin
 Web.Navigate('about:<body topmargin="0" leftmargin="0" marginwidth="0"'+ 
 'rightmargin="0" bottommargin="0" scroll="no"> <marquee  height="'+
 IntToStr(Web.height-5)+'" width="'+IntToStr(Web. width)+
 '"bgcolor="white" scrollamount="4"><small>'+Text+
 '</small></marquee></body>');
end;
```

Ну, или же сразу передавать в процедуру и все настройки:

```pascal
procedure SetRunTextProfy(Web: TWebBrowser; 
  Text, bgcolor, behavior, direction: string; speed: integer);
begin
  Web.Navigate('about:<body topmargin="0" leftmargin="0" marginwidth="0"'+ 
  'rightmargin="0" bottommargin="0" scroll="no"> <marquee  height="'+
  IntToStr(Web.height-5)+'" width="'+IntToStr(Web. width)+
  '"bgcolor="'+bgcolor+'" scrollamount="'+IntToStr(speed)+'" behavior="'+
  behavior+'" direction="'+direction+'" ><small>'
  +Text+'</small></marquee></body>');
end;
```

Если захотите оставить параметры по умолчанию, то можно просто передать пустые строки в нужных параметрах. Данную процедуру можно ещё расширить: например, передавать цвет не строкой, а TColor'ом. Но это вы уже сделаете сами :)

Ну вот и всё. Сегодня вы научились делать бегущую строку аж двумя способами, вспомнили HTML, написали пару полезных процедур. Я надеюсь, что эта статья принесла вам пользу, научила чему-нибудь.


## Other Delphi
{: .t60 }
{% include list-posts tag='delphi' %}
